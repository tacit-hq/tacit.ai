<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Favicon Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: #1a1a1a;
    font-family: system-ui, sans-serif;
    color: #ccc;
    gap: 20px;
  }
  h1 { font-size: 1.2rem; font-weight: 400; }
  #grid {
    display: grid;
    grid-template-columns: repeat(32, 1fr);
    border: 1px solid #444;
    width: 514px;
    height: 514px;
  }
  .pixel {
    width: 16px;
    height: 16px;
    background: white;
    border-right: 1px solid #333;
    border-bottom: 1px solid #333;
    cursor: pointer;
  }
  .pixel.black { background: black; }
  .pixel:hover { opacity: 0.7; }
  #controls {
    display: flex;
    gap: 12px;
    align-items: center;
  }
  button {
    padding: 8px 16px;
    background: #333;
    color: #ccc;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
  }
  button:hover { background: #444; }
  #preview-section {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  #preview {
    border: 1px solid #444;
    image-rendering: pixelated;
  }
</style>
</head>
<body>
<h1>Favicon Editor (32x32)</h1>
<div id="grid"></div>
<div id="controls">
  <button id="clear-btn">Clear (all white)</button>
  <button id="fill-btn">Fill (all black)</button>
  <button id="export-btn">Export PNG</button>
  <button id="save-btn">Save</button>
  <button id="load-btn">Load</button>
</div>
<div id="preview-section">
  <span>Preview:</span>
  <canvas id="preview" width="32" height="32" style="width:64px;height:64px;"></canvas>
</div>

<script>
const grid = document.getElementById('grid');
const pixels = [];
let painting = false;
let paintColor = null;

for (let i = 0; i < 32 * 32; i++) {
  const div = document.createElement('div');
  div.className = 'pixel';
  div.dataset.index = i;
  pixels.push(div);
  grid.appendChild(div);
}

fetch('favicon.json')
  .then(r => r.json())
  .then(data => {
    for (let row = 0; row < 32; row++) {
      for (let col = 0; col < 32; col++) {
        if (data[row] && data[row][col] === 1) {
          pixels[row * 32 + col].classList.add('black');
        }
      }
    }
    updatePreview();
  });

grid.addEventListener('mousedown', (e) => {
  if (!e.target.classList.contains('pixel')) return;
  e.preventDefault();
  painting = true;
  paintColor = e.target.classList.contains('black') ? 'white' : 'black';
  toggle(e.target, paintColor);
});

grid.addEventListener('mouseover', (e) => {
  if (!painting || !e.target.classList.contains('pixel')) return;
  toggle(e.target, paintColor);
});

document.addEventListener('mouseup', () => {
  painting = false;
  paintColor = null;
  updatePreview();
});

grid.addEventListener('click', () => updatePreview());

function toggle(el, color) {
  if (color === 'black') {
    el.classList.add('black');
  } else {
    el.classList.remove('black');
  }
}

function updatePreview() {
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 32, 32);
  for (let i = 0; i < pixels.length; i++) {
    const x = i % 32;
    const y = Math.floor(i / 32);
    ctx.fillStyle = pixels[i].classList.contains('black') ? '#000' : '#fff';
    ctx.fillRect(x, y, 1, 1);
  }
}

document.getElementById('clear-btn').addEventListener('click', () => {
  pixels.forEach(p => p.classList.remove('black'));
  updatePreview();
});

document.getElementById('fill-btn').addEventListener('click', () => {
  pixels.forEach(p => p.classList.add('black'));
  updatePreview();
});

document.getElementById('export-btn').addEventListener('click', () => {
  const canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  for (let i = 0; i < pixels.length; i++) {
    const x = i % 32;
    const y = Math.floor(i / 32);
    ctx.fillStyle = pixels[i].classList.contains('black') ? '#000' : '#fff';
    ctx.fillRect(x, y, 1, 1);
  }
  const link = document.createElement('a');
  link.download = 'favicon.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

document.getElementById('save-btn').addEventListener('click', () => {
  const data = [];
  for (let r = 0; r < 32; r++) {
    const row = [];
    for (let c = 0; c < 32; c++) row.push(pixels[r * 32 + c].classList.contains('black') ? 1 : 0);
    data.push(row);
  }
  const canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  for (let i = 0; i < pixels.length; i++) {
    if (!pixels[i].classList.contains('black')) continue;
    ctx.fillStyle = '#000';
    ctx.fillRect(i % 32, Math.floor(i / 32), 1, 1);
  }
  canvas.toBlob(blob => {
    Promise.all([
      fetch('favicon.json', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }),
      fetch('favicon.png', { method: 'POST', headers: { 'Content-Type': 'application/octet-stream' }, body: blob })
    ])
      .then(results => { if (results.some(r => !r.ok)) throw new Error('Save failed'); })
      .catch(e => alert(e.message));
  }, 'image/png');
});

document.getElementById('load-btn').addEventListener('click', () => {
  fetch('favicon.json')
    .then(r => { if (!r.ok) throw new Error('No favicon.json found'); return r.json(); })
    .then(data => {
      data.forEach((row, r) => {
        row.forEach((v, c) => {
          const i = r * 32 + c;
          if (i < pixels.length) pixels[i].classList.toggle('black', v === 1);
        });
      });
      updatePreview();
    })
    .catch(e => alert(e.message));
});

updatePreview();
</script>
</body>
</html>
