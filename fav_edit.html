<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Favicon Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: #1a1a1a;
    font-family: system-ui, sans-serif;
    color: #ccc;
    gap: 20px;
  }
  h1 { font-size: 1.2rem; font-weight: 400; }
  #grid {
    display: grid;
    grid-template-columns: repeat(32, 1fr);
    border: 1px solid #444;
    width: 514px;
    height: 514px;
    position: relative;
    overflow: hidden;
  }
  .pixel {
    width: 16px;
    height: 16px;
    --pixel-color: transparent;
    background:
      linear-gradient(var(--pixel-color), var(--pixel-color)),
      repeating-conic-gradient(#d0d0d0 0% 25%, #fff 0% 50%) 0 0 / 8px 8px;
    border-right: 1px solid #333;
    border-bottom: 1px solid #333;
    cursor: pointer;
  }
  .pixel:hover { opacity: 0.7; }
  #controls {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    padding: 8px 16px;
    background: #333;
    color: #ccc;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
  }
  button:hover { background: #444; }
  button.tool-active {
    background: #555;
    border-color: #00aaff;
    color: #fff;
  }
  .tool-sep {
    width: 1px;
    height: 24px;
    background: #444;
  }
  #color-picker {
    width: 36px;
    height: 36px;
    padding: 0;
    border: 1px solid #555;
    border-radius: 4px;
    background: none;
    cursor: pointer;
  }
  #color-picker::-webkit-color-swatch-wrapper { padding: 2px; }
  #color-picker::-webkit-color-swatch { border: none; border-radius: 2px; }
  .alpha-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  #alpha-slider {
    width: 80px;
    accent-color: #00aaff;
  }
  #alpha-label {
    font-size: 0.8rem;
    min-width: 36px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }
  #preview-section {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  #preview {
    border: 1px solid #444;
    image-rendering: pixelated;
    background: repeating-conic-gradient(#d0d0d0 0% 25%, #fff 0% 50%) 0 0 / 4px 4px;
  }
  #selection-overlay {
    position: absolute;
    pointer-events: none;
    z-index: 10;
    display: none;
    background-color: rgba(0, 170, 255, 0.08);
    background-image:
      repeating-linear-gradient(90deg, #00aaff 0 4px, transparent 4px 8px),
      repeating-linear-gradient(90deg, #00aaff 0 4px, transparent 4px 8px),
      repeating-linear-gradient(0deg, #00aaff 0 4px, transparent 4px 8px),
      repeating-linear-gradient(0deg, #00aaff 0 4px, transparent 4px 8px);
    background-size: 100% 1.5px, 100% 1.5px, 1.5px 100%, 1.5px 100%;
    background-position: 0 0, 0 100%, 0 0, 100% 0;
    background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
    animation: march 0.4s linear infinite;
  }
  @keyframes march {
    to { background-position: 8px 0, -8px 100%, 0 -8px, 100% 8px; }
  }
</style>
</head>
<body>
<h1>Favicon Editor (32x32)</h1>
<div id="grid"></div>
<div id="controls">
  <button id="paint-btn" class="tool-active">Paint</button>
  <button id="select-btn">Select</button>
  <div class="tool-sep"></div>
  <input type="color" id="color-picker" value="#000000" title="Paint color">
  <div class="alpha-group">
    <input type="range" id="alpha-slider" min="0" max="100" value="100" title="Opacity">
    <span id="alpha-label">100%</span>
  </div>
  <div class="tool-sep"></div>
  <button id="clear-btn">Clear</button>
  <button id="fill-btn">Fill</button>
  <button id="export-btn">Export PNG</button>
  <button id="save-btn">Save</button>
  <button id="load-btn">Load</button>
</div>
<div id="preview-section">
  <span>Preview:</span>
  <canvas id="preview" width="32" height="32" style="width:32px;height:32px;"></canvas>
</div>

<script>
const grid = document.getElementById('grid');
const pixels = [];
const pixelColors = new Array(32 * 32).fill(null); // null = transparent, string = CSS color

// Paint state
let painting = false;
let erasing = false;

// Tool state
let currentTool = 'paint';

// Selection state
let selection = null;
let isSelecting = false;
let isMoving = false;
let selStart = null;
let moveOrigin = null;
let selectionData = null;
let selWidth = 0;
let selHeight = 0;
let savedGridState = null;

// Build grid
for (let i = 0; i < 32 * 32; i++) {
  const div = document.createElement('div');
  div.className = 'pixel';
  div.dataset.index = i;
  pixels.push(div);
  grid.appendChild(div);
}

// Selection overlay
const overlay = document.createElement('div');
overlay.id = 'selection-overlay';
grid.appendChild(overlay);

// Alpha slider label
document.getElementById('alpha-slider').addEventListener('input', (e) => {
  document.getElementById('alpha-label').textContent = e.target.value + '%';
});

// Load saved data
fetch('favicon.json')
  .then(r => r.json())
  .then(data => {
    for (let row = 0; row < 32; row++) {
      for (let col = 0; col < 32; col++) {
        if (!data[row]) continue;
        const v = data[row][col];
        if (v === 1) setPixel(row * 32 + col, 'rgba(0,0,0,1)');
        else if (typeof v === 'string') setPixel(row * 32 + col, v);
      }
    }
    updatePreview();
  });

// === Helpers ===

function getSelectedColor() {
  const hex = document.getElementById('color-picker').value;
  const alpha = parseInt(document.getElementById('alpha-slider').value) / 100;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function setPixel(index, color) {
  pixelColors[index] = color;
  pixels[index].style.setProperty('--pixel-color', color || 'transparent');
}

function getGridCoords(e) {
  const rect = grid.getBoundingClientRect();
  const x = e.clientX - rect.left - grid.clientLeft;
  const y = e.clientY - rect.top - grid.clientTop;
  const cellW = grid.clientWidth / 32;
  const cellH = grid.clientHeight / 32;
  return {
    row: Math.max(0, Math.min(31, Math.floor(y / cellH))),
    col: Math.max(0, Math.min(31, Math.floor(x / cellW)))
  };
}

function normalizeRect(s) {
  return {
    r1: Math.min(s.r1, s.r2),
    c1: Math.min(s.c1, s.c2),
    r2: Math.max(s.r1, s.r2),
    c2: Math.max(s.c1, s.c2)
  };
}

function isInsideSelection(row, col) {
  if (!selection) return false;
  const s = normalizeRect(selection);
  return row >= s.r1 && row <= s.r2 && col >= s.c1 && col <= s.c2;
}

function captureSelection() {
  const s = selection;
  const data = [];
  for (let r = s.r1; r <= s.r2; r++) {
    const row = [];
    for (let c = s.c1; c <= s.c2; c++) {
      row.push(pixelColors[r * 32 + c]);
    }
    data.push(row);
  }
  return data;
}

function pastePixels(data, r1, c1) {
  for (let r = 0; r < data.length; r++) {
    for (let c = 0; c < data[r].length; c++) {
      const tr = r1 + r;
      const tc = c1 + c;
      if (tr >= 0 && tr < 32 && tc >= 0 && tc < 32) {
        setPixel(tr * 32 + tc, data[r][c]);
      }
    }
  }
}

function saveGridState() {
  return pixelColors.slice();
}

function restoreGridState(state) {
  for (let i = 0; i < state.length; i++) setPixel(i, state[i]);
}

function updateOverlay() {
  if (!selection) {
    overlay.style.display = 'none';
    return;
  }
  const s = normalizeRect(selection);
  const cellW = grid.clientWidth / 32;
  const cellH = grid.clientHeight / 32;
  overlay.style.display = 'block';
  overlay.style.left = (s.c1 * cellW) + 'px';
  overlay.style.top = (s.r1 * cellH) + 'px';
  overlay.style.width = ((s.c2 - s.c1 + 1) * cellW) + 'px';
  overlay.style.height = ((s.r2 - s.r1 + 1) * cellH) + 'px';
}

function clearSelection() {
  selection = null;
  selectionData = null;
  isSelecting = false;
  isMoving = false;
  savedGridState = null;
  updateOverlay();
}

function updatePreview() {
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 32, 32);
  for (let i = 0; i < pixels.length; i++) {
    if (!pixelColors[i]) continue;
    const x = i % 32;
    const y = Math.floor(i / 32);
    ctx.fillStyle = pixelColors[i];
    ctx.fillRect(x, y, 1, 1);
  }
}

function setTool(tool) {
  currentTool = tool;
  document.getElementById('paint-btn').classList.toggle('tool-active', tool === 'paint');
  document.getElementById('select-btn').classList.toggle('tool-active', tool === 'select');
  if (tool === 'paint') {
    clearSelection();
    grid.style.cursor = 'pointer';
  } else {
    grid.style.cursor = 'crosshair';
  }
}

// === Tool switching ===

document.getElementById('paint-btn').addEventListener('click', () => setTool('paint'));
document.getElementById('select-btn').addEventListener('click', () => setTool('select'));

// === Mouse events ===

grid.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const coords = getGridCoords(e);

  if (currentTool === 'paint') {
    if (!e.target.classList.contains('pixel')) return;
    const idx = coords.row * 32 + coords.col;
    painting = true;
    erasing = pixelColors[idx] !== null;
    if (erasing) {
      setPixel(idx, null);
    } else {
      setPixel(idx, getSelectedColor());
    }

  } else if (currentTool === 'select') {
    if (selection && isInsideSelection(coords.row, coords.col)) {
      isMoving = true;
      selStart = coords;
      moveOrigin = { r1: selection.r1, c1: selection.c1 };
      selWidth = selection.c2 - selection.c1 + 1;
      selHeight = selection.r2 - selection.r1 + 1;
      savedGridState = saveGridState();
      selectionData = captureSelection();
    } else {
      clearSelection();
      isSelecting = true;
      selStart = coords;
      selection = { r1: coords.row, c1: coords.col, r2: coords.row, c2: coords.col };
      updateOverlay();
    }
  }
});

grid.addEventListener('mouseover', (e) => {
  if (currentTool === 'paint' && painting && e.target.classList.contains('pixel')) {
    const idx = parseInt(e.target.dataset.index);
    if (erasing) {
      setPixel(idx, null);
    } else {
      setPixel(idx, getSelectedColor());
    }
  }
});

document.addEventListener('mousemove', (e) => {
  if (currentTool === 'select') {
    const coords = getGridCoords(e);

    if (isSelecting) {
      selection.r2 = coords.row;
      selection.c2 = coords.col;
      updateOverlay();

    } else if (isMoving) {
      const dr = coords.row - selStart.row;
      const dc = coords.col - selStart.col;

      restoreGridState(savedGridState);
      for (let r = moveOrigin.r1; r < moveOrigin.r1 + selHeight; r++) {
        for (let c = moveOrigin.c1; c < moveOrigin.c1 + selWidth; c++) {
          if (r >= 0 && r < 32 && c >= 0 && c < 32) {
            setPixel(r * 32 + c, null);
          }
        }
      }
      const newR1 = moveOrigin.r1 + dr;
      const newC1 = moveOrigin.c1 + dc;
      pastePixels(selectionData, newR1, newC1);

      selection = { r1: newR1, c1: newC1, r2: newR1 + selHeight - 1, c2: newC1 + selWidth - 1 };
      updateOverlay();

    } else if (selection) {
      if (isInsideSelection(coords.row, coords.col)) {
        grid.style.cursor = 'move';
      } else {
        grid.style.cursor = 'crosshair';
      }
    }
  }
});

document.addEventListener('mouseup', () => {
  if (painting) {
    painting = false;
    erasing = false;
    updatePreview();
  }
  if (isSelecting) {
    isSelecting = false;
    if (selection) selection = normalizeRect(selection);
    updateOverlay();
  }
  if (isMoving) {
    isMoving = false;
    savedGridState = null;
    updatePreview();
  }
});

// === Keyboard ===

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    clearSelection();
    return;
  }

  if (selection && currentTool === 'select' && !isSelecting && !isMoving) {
    let dr = 0, dc = 0;
    if (e.key === 'ArrowUp') dr = -1;
    else if (e.key === 'ArrowDown') dr = 1;
    else if (e.key === 'ArrowLeft') dc = -1;
    else if (e.key === 'ArrowRight') dc = 1;
    else return;

    e.preventDefault();
    const data = captureSelection();

    for (let r = selection.r1; r <= selection.r2; r++) {
      for (let c = selection.c1; c <= selection.c2; c++) {
        if (r >= 0 && r < 32 && c >= 0 && c < 32) {
          setPixel(r * 32 + c, null);
        }
      }
    }

    selection.r1 += dr; selection.r2 += dr;
    selection.c1 += dc; selection.c2 += dc;

    pastePixels(data, selection.r1, selection.c1);
    updateOverlay();
    updatePreview();
  }
});

// === Buttons ===

grid.addEventListener('click', () => updatePreview());

document.getElementById('clear-btn').addEventListener('click', () => {
  clearSelection();
  for (let i = 0; i < pixels.length; i++) setPixel(i, null);
  updatePreview();
});

document.getElementById('fill-btn').addEventListener('click', () => {
  clearSelection();
  const c = getSelectedColor();
  for (let i = 0; i < pixels.length; i++) setPixel(i, c);
  updatePreview();
});

document.getElementById('export-btn').addEventListener('click', () => {
  const canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 32, 32);
  for (let i = 0; i < pixels.length; i++) {
    if (!pixelColors[i]) continue;
    ctx.fillStyle = pixelColors[i];
    ctx.fillRect(i % 32, Math.floor(i / 32), 1, 1);
  }
  const link = document.createElement('a');
  link.download = 'favicon.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

document.getElementById('save-btn').addEventListener('click', () => {
  const data = [];
  for (let r = 0; r < 32; r++) {
    const row = [];
    for (let c = 0; c < 32; c++) {
      const color = pixelColors[r * 32 + c];
      row.push(color || 0);
    }
    data.push(row);
  }
  const canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 32, 32);
  for (let i = 0; i < pixels.length; i++) {
    if (!pixelColors[i]) continue;
    ctx.fillStyle = pixelColors[i];
    ctx.fillRect(i % 32, Math.floor(i / 32), 1, 1);
  }
  canvas.toBlob(blob => {
    Promise.all([
      fetch('favicon.json', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }),
      fetch('favicon.png', { method: 'POST', headers: { 'Content-Type': 'application/octet-stream' }, body: blob })
    ])
      .then(results => { if (results.some(r => !r.ok)) throw new Error('Save failed'); })
      .catch(e => alert(e.message));
  }, 'image/png');
});

document.getElementById('load-btn').addEventListener('click', () => {
  fetch('favicon.json')
    .then(r => { if (!r.ok) throw new Error('No favicon.json found'); return r.json(); })
    .then(data => {
      clearSelection();
      data.forEach((row, r) => {
        row.forEach((v, c) => {
          const i = r * 32 + c;
          if (i >= pixels.length) return;
          if (v === 1) setPixel(i, 'rgba(0,0,0,1)');
          else if (typeof v === 'string') setPixel(i, v);
          else setPixel(i, null);
        });
      });
      updatePreview();
    })
    .catch(e => alert(e.message));
});

updatePreview();
</script>
</body>
</html>
